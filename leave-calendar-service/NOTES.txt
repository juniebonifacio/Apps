http://localhost:8080/leave-calendar-service/hello

http://localhost:8080/leave-calendar-service/services/getAllItems

http://localhost:8080/leave-calendar-service/services/getAllKindsOfTimeOffs
http://localhost:8080/leave-calendar-service/services/getAllEmployeeTimeOffs


Database Modeling:

Credits to the owner. I am loosely basing my database with the sample.
http://www.databaseanswers.org/data_models/employees/index.htm

A. Planning your database:

	1. What's the point?
	- This database is to support the Leave Calendar App that will make it easier for the team lead.
	
	2. What do you have already?
	Physical items ie. Forms - None.
	
	People and expertise - me
	
	Existing database - none
	
	3. What Entities do you have?
	
	
	- you will create separate tables for each entity.
	- use Singular nouns for your table names.
	- check the relationships of those entities.


	Therefore, list of entities (which will be the table names):
		User
		Role
		TimeOff


Database system Isolation Levels, in database transactions:
-READ UNCOMMITTED.
-READ COMMITTED (protecting against dirty reads)
-REPEATABLE READ (protecting against dirty and non-repeatable reads)
-SERIALIZABLE (protecting against dirty, non-repeatable reads and phantom reads)

https://vladmihalcea.com/2014/12/23/a-beginners-guide-to-transaction-isolation-levels-in-enterprise-java/

==================================
Error:
org.hibernate.LazyInitializationException: failed to lazily initialize a collection of role: com.domain.hibernate.TimeOffVO.listOfEmployeeTimeOffs, 
could not initialize proxy - no Session
Solution:
Make sure that in all of your Business Layer, use the @Transactional annotation
wrong:
	@Override
	public List<TimeOffBO> getAllTimeOffs() {
		List<TimeOffBO> timeOffs = new ArrayList<TimeOffBO>();
		
		for (TimeOffVO timeOffVO : timeOffDao.getAllTimeOffs()) {
			timeOffs.add(getMapper().map(timeOffVO, TimeOffBO.class));
		}
		
		return timeOffs;
	}

correct:
	@Override
	@Transactional
	public List<TimeOffBO> getAllTimeOffs() {
		List<TimeOffBO> timeOffs = new ArrayList<TimeOffBO>();
		
		for (TimeOffVO timeOffVO : timeOffDao.getAllTimeOffs()) {
			timeOffs.add(getMapper().map(timeOffVO, TimeOffBO.class));
		}
		
		return timeOffs;
	}

==================================
Error:
leave-calendar-service threw exception: org.hibernate.hql.internal.ast.QuerySyntaxException: TimeOffVO is not mapped [FROM TimeOffVO]
Solution: 
Edit the file persistence.xml under  src/main/webapp/META-INF, not the one under the src main java
==================================
Error:
20:45:44,097 ERROR [org.apache.catalina.core.ContainerBase.[jboss.web].[default-host].[/leave-calendar-service]] (MSC service thread 1-8) 
Servlet /leave-calendar-service threw load() exception: org.hsqldb.HsqlException: user lacks privilege or object not found: USER_ID
Solution:
Root cause was I renamed the EmployeeTimeOffVO ownerId column from USER_ID to OWNER_ID. 
	/** User Id where this TimeOff belongs */
	@Column(name = "OWNER_ID")
	private int ownerId;

In the DDL statement, make sure that your FOREIGN KEY IS CORRECT:
wrong:
CREATE TABLE EMPLOYEE_TIMEOFF(
	EMPLOYEE_TIMEOFF_ID bigint GENERATED BY DEFAULT AS IDENTITY, 
	OWNER_ID bigint NOT NULL,
	TIMEOFF_ID bigint NOT NULL,
	DESCRIPTION varchar(100),
	PRIMARY KEY (EMPLOYEE_TIMEOFF_ID),
	FOREIGN KEY (USER_ID) REFERENCES USER (USER_ID), <--this was the cause of the error, USER_ID should be OWNER_ID
	FOREIGN KEY (TIMEOFF_ID) REFERENCES TIMEOFF (TIMEOFF_ID)
);

correct:
CREATE TABLE EMPLOYEE_TIMEOFF(
	EMPLOYEE_TIMEOFF_ID bigint GENERATED BY DEFAULT AS IDENTITY, 
	OWNER_ID bigint NOT NULL,
	TIMEOFF_ID bigint NOT NULL,
	DESCRIPTION varchar(100),
	PRIMARY KEY (EMPLOYEE_TIMEOFF_ID),
	FOREIGN KEY (OWNER_ID) REFERENCES USER (USER_ID),
	FOREIGN KEY (TIMEOFF_ID) REFERENCES TIMEOFF (TIMEOFF_ID)
);
==================================
Error: 
org.springframework.web.util.NestedServletException: 
Request processing failed; nested exception is java.lang.ClassCastException: 
com.domain.hibernate.CategoryVO_$$_javassist_39 cannot be cast to javassist.util.proxy.Proxy
Solution:
Root Cause was we experimented on putting fetch=FetchType.LAZY on ItemVO. Do not put fetch=FetchType.LAZY on the @OneToMany mapping.

In other words, do not put fetch=FetchType.LAZY on the mapping table/linking table entity.

wrong:
    @ManyToOne(optional=false, fetch=FetchType.LAZY, targetEntity=UserVO.class)
    @JoinColumn(name="OWNER_ID", referencedColumnName="USER_ID", insertable=false, updatable=false)
    @JsonBackReference
    private UserVO user; //Back Reference To User: One Item has an Owner.
correct:
    @ManyToOne(optional=false, targetEntity=UserVO.class)
    @JoinColumn(name="OWNER_ID", referencedColumnName="USER_ID", insertable=false, updatable=false)
    @JsonBackReference
    private UserVO user; //Back Reference To User: One Item has an Owner.
    
==================================
Defect:
Lazy Loading not working on the operation http://localhost:8080/leave-calendar-service/services/getAllUsers
Particularly, "itemsList" and "listOfEmployeeTimeOffs" should be lazy loaded and not have values. Still Eager fetched.
Only name, role, and password should have values, otherwise you have large data affecting performance issues.

[{
	"id": 0,
	"name": "Che",
	"role": "User",
	"password": "Passw0rd",
	"listOfEmployeeTimeOffs": [],
	"itemsList": []
}, {
	"id": 1,
	"name": "Jay",
	"role": "User",
	"password": "Passw0rd",
	"listOfEmployeeTimeOffs": [{
		"id": 0,
		"ownerId": 1,
		"timeOffId": 1,
		"description": "test"
	}],
	"itemsList": []
}, {
	"id": 2,
	"name": "Amiya",
	"role": "User",
	"password": "Passw0rd",
	"listOfEmployeeTimeOffs": [],
	"itemsList": [{
		"id": 1,
		"ownerId": 2,
		"categoryId": 0,
		"name": "555 Sardines",
		"description": null,
		"price": null,
		"consumptionDate": null,
		"expiryDate": null,
		"available": true
	}]
}, {
	"id": 3,
	"name": "Zofia",
	"role": "User",
	"password": "Passw0rd",
	"listOfEmployeeTimeOffs": [],
	"itemsList": [{
		"id": 0,
		"ownerId": 3,
		"categoryId": 0,
		"name": "Family Sardines",
		"description": null,
		"price": null,
		"consumptionDate": null,
		"expiryDate": null,
		"available": false
	}, {
		"id": 2,
		"ownerId": 3,
		"categoryId": 0,
		"name": "555 Sardines",
		"description": null,
		"price": null,
		"consumptionDate": null,
		"expiryDate": null,
		"available": true
	}, {
		"id": 3,
		"ownerId": 3,
		"categoryId": 0,
		"name": "Mega Sardines",
		"description": null,
		"price": null,
		"consumptionDate": null,
		"expiryDate": null,
		"available": false
	}]
}]

Solution: 

==================================